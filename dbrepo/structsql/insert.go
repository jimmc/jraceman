package structsql

import (
  "reflect"
  "strings"

  "github.com/jimmc/jraceman/dbrepo/conn"

  "github.com/golang/glog"
)

// Insert inserts a new row into the database using the sql string
// generated by InsertSql.
func Insert(db conn.DB, tableName string, entity interface{}, ID string) error {
  sql, values := InsertSql(tableName, entity)
  res, err := db.Exec(sql, values...)
  return RequireOneResult(res, err, "Inserted", tableName, ID)
}

// InsertSql generates an SQL INSERT statement using
// the fields of the given struct. For each field in the struct:
//   * If the field is a nil pointer, it is ignored.
//   * The field name is converted to lower case.
func InsertSql(tableName string, entity interface{}) (string, []interface{}) {
  val := reflect.Indirect(reflect.ValueOf(entity))
  typ := val.Type()
  numFields := typ.NumField()
  columnNames := make([]string, 0)
  values := make([]interface{}, 0)
  placeHolders := make([]string, 0)
  for i := 0; i < numFields; i++ {
    fieldType := typ.Field(i)
    columnName := strings.ToLower(fieldType.Name)
    vf := val.Field(i)
    if !(vf.Kind() == reflect.Ptr && vf.IsNil()) {  // Omit nil pointers
      if vf.Kind() == reflect.Ptr {
        vf = vf.Elem()  // Dereference the pointer to get the value
      }
      fieldValue := vf.Interface()
      columnNames = append(columnNames, columnName)
      values = append(values, fieldValue)
      placeHolders = append(placeHolders, "?")
    }
  }
  sql := "INSERT into " + tableName + "(" + strings.Join(columnNames, ",") + ")" +
      " values (" + strings.Join(placeHolders,",") + ");"
  glog.V(1).Infof("InsertSql: %v\n", sql)
  glog.V(1).Infof("  values: %v\n", values)
  return sql, values
}
